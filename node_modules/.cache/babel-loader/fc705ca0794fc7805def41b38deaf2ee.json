{"ast":null,"code":"// import { apiOptions } from '../../../../axios/geoApiOptions';\n// interface ICity {\n//   name: string;\n//   countryCode: string;\n//   latitude: string;\n//   longitude: string;\n// }\n// const loadOptions = async (inputText: string) => {\n//   return await fetch(\n//     `https://wft-geo-db.p.rapidapi.com/v1/geo/cities?minPopulation=1000000&namePrefix=${inputText}`,\n//     apiOptions,\n//   )\n//     .then(response => response.json())\n//     .then(response => ({\n//       options: response.data.map((city: ICity) => ({\n//         label: `${city.name} ${city.countryCode}`,\n//         value: { latitude: city.latitude, longitude: city.longitude },\n//       })),\n//     }))\n//     .catch(err => console.error(err));\n// };\n// export default loadOptions;\nconst options = [];\n\nfor (let i = 0; i < 50; ++i) {\n  options.push({\n    value: i + 1,\n    label: `Option ${i + 1}`\n  });\n}\n\nconst sleep = ms => new Promise(resolve => {\n  setTimeout(() => {\n    resolve();\n  }, ms);\n});\n\nconst loadOptions = async (search, prevOptions) => {\n  await sleep(1000);\n  let filteredOptions;\n\n  if (!search) {\n    filteredOptions = options;\n  } else {\n    const searchLower = search.toLowerCase();\n    filteredOptions = options.filter(_ref => {\n      let {\n        label\n      } = _ref;\n      return label.toLowerCase().includes(searchLower);\n    });\n  }\n\n  const hasMore = filteredOptions.length > prevOptions.length + 10;\n  const slicedOptions = filteredOptions.slice(prevOptions.length, prevOptions.length + 10);\n  return {\n    options: slicedOptions,\n    hasMore\n  };\n};\n\nexport default loadOptions;","map":{"version":3,"sources":["C:/apps/weather/src/pages/Home/components/Search/loadOptions.ts"],"names":["options","i","push","value","label","sleep","ms","Promise","resolve","setTimeout","loadOptions","search","prevOptions","filteredOptions","searchLower","toLowerCase","filter","includes","hasMore","length","slicedOptions","slice"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,OAA2C,GAAG,EAApD;;AACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwB,EAAEA,CAA1B,EAA6B;AAC3BD,EAAAA,OAAO,CAACE,IAAR,CAAa;AACXC,IAAAA,KAAK,EAAEF,CAAC,GAAG,CADA;AAEXG,IAAAA,KAAK,EAAG,UAASH,CAAC,GAAG,CAAE;AAFZ,GAAb;AAID;;AAED,MAAMI,KAAK,GAAGC,EAAE,IACd,IAAIC,OAAJ,CAAkBC,OAAO,IAAI;AAC3BC,EAAAA,UAAU,CAAC,MAAM;AACfD,IAAAA,OAAO;AACR,GAFS,EAEPF,EAFO,CAAV;AAGD,CAJD,CADF;;AAOA,MAAMI,WAAW,GAAG,OAAOC,MAAP,EAAeC,WAAf,KAA+B;AACjD,QAAMP,KAAK,CAAC,IAAD,CAAX;AAEA,MAAIQ,eAAJ;;AACA,MAAI,CAACF,MAAL,EAAa;AACXE,IAAAA,eAAe,GAAGb,OAAlB;AACD,GAFD,MAEO;AACL,UAAMc,WAAW,GAAGH,MAAM,CAACI,WAAP,EAApB;AAEAF,IAAAA,eAAe,GAAGb,OAAO,CAACgB,MAAR,CAAe;AAAA,UAAC;AAAEZ,QAAAA;AAAF,OAAD;AAAA,aAC/BA,KAAK,CAACW,WAAN,GAAoBE,QAApB,CAA6BH,WAA7B,CAD+B;AAAA,KAAf,CAAlB;AAGD;;AAED,QAAMI,OAAO,GAAGL,eAAe,CAACM,MAAhB,GAAyBP,WAAW,CAACO,MAAZ,GAAqB,EAA9D;AACA,QAAMC,aAAa,GAAGP,eAAe,CAACQ,KAAhB,CACpBT,WAAW,CAACO,MADQ,EAEpBP,WAAW,CAACO,MAAZ,GAAqB,EAFD,CAAtB;AAKA,SAAO;AACLnB,IAAAA,OAAO,EAAEoB,aADJ;AAELF,IAAAA;AAFK,GAAP;AAID,CAxBD;;AA0BA,eAAeR,WAAf","sourcesContent":["// import { apiOptions } from '../../../../axios/geoApiOptions';\r\n// interface ICity {\r\n//   name: string;\r\n//   countryCode: string;\r\n//   latitude: string;\r\n//   longitude: string;\r\n// }\r\n// const loadOptions = async (inputText: string) => {\r\n//   return await fetch(\r\n//     `https://wft-geo-db.p.rapidapi.com/v1/geo/cities?minPopulation=1000000&namePrefix=${inputText}`,\r\n//     apiOptions,\r\n//   )\r\n//     .then(response => response.json())\r\n//     .then(response => ({\r\n//       options: response.data.map((city: ICity) => ({\r\n//         label: `${city.name} ${city.countryCode}`,\r\n//         value: { latitude: city.latitude, longitude: city.longitude },\r\n//       })),\r\n//     }))\r\n//     .catch(err => console.error(err));\r\n// };\r\n// export default loadOptions;\r\nconst options: { value: number; label: string }[] = [];\r\nfor (let i = 0; i < 50; ++i) {\r\n  options.push({\r\n    value: i + 1,\r\n    label: `Option ${i + 1}`,\r\n  });\r\n}\r\n\r\nconst sleep = ms =>\r\n  new Promise<void>(resolve => {\r\n    setTimeout(() => {\r\n      resolve();\r\n    }, ms);\r\n  });\r\n\r\nconst loadOptions = async (search, prevOptions) => {\r\n  await sleep(1000);\r\n\r\n  let filteredOptions;\r\n  if (!search) {\r\n    filteredOptions = options;\r\n  } else {\r\n    const searchLower = search.toLowerCase();\r\n\r\n    filteredOptions = options.filter(({ label }) =>\r\n      label.toLowerCase().includes(searchLower),\r\n    );\r\n  }\r\n\r\n  const hasMore = filteredOptions.length > prevOptions.length + 10;\r\n  const slicedOptions = filteredOptions.slice(\r\n    prevOptions.length,\r\n    prevOptions.length + 10,\r\n  );\r\n\r\n  return {\r\n    options: slicedOptions,\r\n    hasMore,\r\n  };\r\n};\r\n\r\nexport default loadOptions;\r\n"]},"metadata":{},"sourceType":"module"}